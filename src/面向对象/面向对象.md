#一.面向对象
##1.面向对象的有哪些特征？
1.封装：  
封装通常认为是将数据和数据的操作方法绑定起来，对数据的操作只能通过已定义的方法。面向对象的本质就是将现实世界的一切都当做一系列的对象看待。

2.继承:  
继承就是从已有类中继承信息创建新类的过程。提供可继承信息的类被称为父类（超类），继承的类被称为子类。继承让变化中的软件提供了一定的延续性，同时继承也是封装程序中可变因素的重要手段。

3.多态:   
多态是指不同的子类可以引用父类中的相同的方法，但是会有不同的实现。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。
  
多态的的必要条件：（1）必须要有继承（2）必须要有方法的重写（3）必须要有向上造型。（父类的引用指向子类的对象，这样同样的引用会根据子类对象的不同表现不同的行为）
##2.类修饰符public，private，protected，default的区别
 外部类只能用public，default修饰;内部类和类的属性可以用四种修饰符修饰
 ***
 四种访问修饰符的权限
 
 |**修饰符**|**当前类**|**同包类**|**子类**|**其他包**|
 | :-----   | ----:    | :----: |:----: |:----: |
 |public	|√  |√	|√	|√|
 |protected	|√	|√	|√	|×|
 |default	|√	|√	|×  |×|
 |private	|√	|×	|×	|×|
##3.内部类和外部类的区别？
内部类的好处在于实现功能的隐藏，减少内存开销，提高运行程序运行速度

内部类与外部类的联系

内部类可以访问外部类的所有属性和方法（如在成员变量或者成员方法前面，加上Private 关键字，则其他类就无法调用这个类中的成员方法或则和成员变量。但是，如果这个类有成员内部类，则不受这方面的限制。），内部类与外部类有相同的属性和方法时优先调用内部类的属性和方法。外部类只能访问内部类的静态常量，或者通过创建内部类的方法来访问内部的成员属性和成员方法，内部类定义的静态常量可以全局访问。

参考:<https://blog.csdn.net/u013728021/article/details/87358517>
##4.基本数据类型
###(1)如何理解java基本数据类型？
什么是变量？
一个变量就是代表内存中的一块空间，用来存储数据。

变量就是容纳数据的容器。

用通俗的说就是：在程序运行中会用到数据，但是数据又不是固定的（固定的叫**常量**），此时需要变量去存储数据。

在java中必须先定义类型，再去使用存储数据，只要定义了变量，就占用了一块内存空间。例如：定义 `int a;` 
定义一个变量就是：数据类型+变量名.
针对上述代码理解的话就是在内存空间里，开辟了一个命名为a的空间用来存储数据，这个空间的类型为int。

###(2)8种基本数据类型：byte,short,int,long,double,float,boolean,char
Java中最小的计算单元为字节，1字节=8位（bit）
整型：

java中的整型数字默认是int型 

 |序号       |数据类型   |位数     | 默认值 |取值范围  |举例说明  |  
 | :-----:   | :----:    | :----: |:----: |:----: |  :----: |  
 | 1    | byte(位)	     | 8(1字节)	| 0	 | -2^7 - 2^7-1(-128~127)	|byte b = 10;  |    
 | 2	| short(短整数)	 | 16(2字节)	| 0	 | -2^15 - 2^15-1(-32768~32767)|	short s = 10;  |    
 | 3	| int(整数)	     | 32(4字节)	| 0  |	-2^31 - 2^31-1(-21亿~21亿)|	int i = 10;  |    
 | 4	| long(长整数)	 | 64(8字节)	| 0	 |-2^63 - 2^63-1|	long l = 10l;  |    
 | 5	| float(单精度)	 | 32(4字节)	| 0.0|	2的-149次方~ 2的128次方-1|	float f = 10.0f;    |    
 | 6    | double(双精度) | 64(8字节)	| 0.0|	2的-1074次方~2的1024次方-1	|double d = 10.0d;  |    
 | 7	| char(字符)	 | 16(2字节)	| 空 |	0 - 2^16-1(两个字节即十六位来表示，因为是无符号数，所以为2的16次方，数值范围就为：0 - 2^16-1)	|char c = 'c';  |    
 | 8	| boolean(布尔值)|  8(1字节)	| false |	true、false|	boolean b = true;  |    
 

浮点型：

java中的浮点型数字默认是double型 

float:4字节，32bit，单精度浮点数（只精确保存了前7位，从第八位开始就要加上第九位四舍五入的进位）
double:8字节，64bit，双精度浮点数（只精确保存了前15位，从第十六位开始就要加上第十七位四舍五入的进位）

float和double都有精度损失问题：原因就是二进制无法准确表示0.99,就像十进制无法准确表示1/3一样。

字符型：
char:2字节，16bit

布尔型：
boolean：1字节，8bit

###(3)二进制和十进制的转化
十进制的整数和小数转化为二进制方法不同，要分别转化：

整数部分用除二取余，倒序排列的方法转化为二进制。
例如10转化为二进制：

10/2 = 5 ------- 0
5/2  = 2 ------- 1
2/2  = 1 ------- 0
1/2  = 0 ------- 1

再倒序排序得到10的二进制：1010

小数部分：将该数字乘以2，取出整数部分作为二进制表示的第1位；然后再将小数部分乘以2，将得到的整数部分作为二进制表示的第2位；以此类推，知道小数部分为0。
下面我们具体计算一下0.6的小数表示过程

0.6 * 2 = 1.2 ——————- 1   
0.2 * 2 = 0.4 ——————- 0   
0.4 * 2 = 0.8 ——————- 0   
0.8 * 2 = 1.6 ——————- 1   
0.6 * 2 = 1.2 ——————- 1   

会出现循环，这也是编程语言中表示小数会出现误差的原因。0.6转化为二进制为1001 1001 1001 1001 …… ，10.6 转化为二进制为1010.100110011001……

###（4）long和double的区别？取值范围？
double是n*2^m(n乘以2的m次方)这种形式存储的，只需要记录n和m两个数就行了，m的值影响范围大，所以表示的范围比long大。
但是m越大，n的精度就越小，所以double并不能把它所表示的范围里的所有数都能精确表示出来，而long就可以。

long可以准确存储19位数字，而double只能准备存储16位数字。double由于有exp位，可以存16位以上的数字，但是需要以低位的不精确作为代价。如果需要高于19位数字的精确存储，则必须用BigInteger来保存，当然会牺牲一些性能。

参考：<https://blog.csdn.net/jdr0212/article/details/8213146?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase>


参考：<https://www.cnblogs.com/LiaHon/p/11043238.html>
##5.原码，反码和补码。
正数的原码，反码,补码都是自己本身，  
负数的反码是除符号位之外其他位取反，  
负数的补码是反码+1.  
计算机为了运算方便，设计简单。设计用符号位参与运算，所以有了反码和补码。真值和机器码。
<https://blog.csdn.net/weixin_29467225/article/details/87448369?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase>
##6.short s1 = 1; s1 = s1 + 1;有错吗？short s1 = 1; s1 += 1;有错吗？

对于short s1 = 1; s1 = s1 + 1；由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。

而short s1 = 1; s1 += 1；+=操作符会进行隐式自动类型转换，是 Java 语言规定的运算符；Java编译器会对它进行特殊处理，因此可以正确编译。因为s1+= 1;相当于s1 = (short)(s1 + 1)。
##7.java中的数据类型转换？强制类型转换+自动类型转换
自动类型转换：

如果以下 2 个条件都满足，那么将一种类型的数据赋给另外一种类型变量的时，将执行自动类型转换（automatic type conversion）。
1、两种数据类型彼此兼容
2、目标类型的取值范围大于源数据类型（低级类型数据转换成高级类型数据）

在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。自动转换的规则是从低级类型数据转换成高级类型数据。转换规则如下：
1、数值型数据的转换：byte→short→int→long→float→double。
2、字符型转换为整型：char→int。

强制类型转换：
尽管自动类型转换是很有帮助的，但并不能满足所有的编程需要。例如，如果你需要将 double 型的值赋给一个 int 型的变量，你将怎么办？
这种转换不会自动进行，因为 double 型的变化范围比 int 型的要小。这种转换有使成为“缩小转换”，因为你肯定要将源数据类型的值变小才能适合目标数据类型。
所以当两种数据类型不兼容，或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行强制类型转换
    
参考：<http://c.biancheng.net/view/796.html>

##8.java中equals和==的区别？

== 比较的是值是否相等，对于基本数据类型值相等即返回true；引用类型比较引用的对象地址是否相同，相同则返回true。 
 
equals方法则是继承自Object类的方法，可以自己重写(不重写则调用Object的equals方法，就和==的效果是相同的了)。对于在Object类型的equals比较则是调用==比较的。

最常用的String.equals方法，通过阅读源码：
```
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```
可以发现String.equals实际是比较的字符串的内容是否一样。也就是说如果像String、Date这些重写equals的类，你可要小心了。使用的时候会和Object的不一样。

还有一个小问题需要注意，java中会有字符串池和常量池的东西，如果创建对象的时候在池中已经有了则返回池中的对象引用地址，不会新建对象了。在比较的时候需要注意。
##9.&和&&的区别？
1、&运算符有两种用法：(1)按位与；(2)逻辑与。
2、&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，

##10.引用数据类型
###（1）引用数据类型的创建过程？
基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。

引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。

例如，有一个类Person,有属性name,age,带有参的构造方法，

Person p = new Person("zhangsan",20);

在内存中的具体创建过程是：

1.首先在栈内存中位其p分配一块空间;

2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值""，0；

3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作；

4.调用构造方法，为两个属性赋值为"Tom",20；（注意这个时候p与Person对象之间还没有建立联系）；

5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。

